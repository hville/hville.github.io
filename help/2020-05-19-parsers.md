---
title: ":bookmark_tabs: parsers"
date: 2015-05-23
layout: post
---
* chart parser (dynamic) (can be top down or bottom up)
  * Earley On^3, low efficiency, flexible
  * Cocke-Younger-Kasami (CYK) On^3; bottom-up; dynamic; high eficiency; one of the most efficient worst-case
* probabilistic
  * inside-outside
* top-down
  * recursive descent parser (fails with left recursive grammar); unlimited lookahead; worst case exponential time
    * However, recursive-descent is less efficient for expression syntaxes, especially for languages with lots of operators at different precedence levels. With one function per rule, you can easily end up with lots of calls even for short, trivial expressions, just to get to the right level in the grammar.
  * LL linear
  * LL(k) *k lookahead*
  * **Pratt parser (1973)** tokens instead of grammar rules == top-down operator precedence
  * packrat; recursive memoized descent linear time; lots of storage;
* bottom-up
  * LR (state machine)
    * Canonical LR
    * LALR (Lookahead LR) (shift-reduce)
    * SLR (recursive ascent)
    * Operator-precedence parser
    * Simple precedence parser
  * GLR linear => On^3

# Top-Down Operator Precedence Parsing (Pratt 1973)

https://effbot.org/zone/tdop-index.htm

http://crockford.com/javascript/tdop/tdop.html (2007-02-21)
* Token < Symbol < {nud led}
  * `lbp:Integer`
  * `nud:()=>` (null denotation; used at the beginning of construct)
  * `led:()=>`, (left denotation; used inside the construct, to the left of the rest of the construct)

The “lbp” value is a binding power, and it controls operator precedence; the higher the value, the tighter a token binds to the tokens that follow.
* symbolFactory(id, bindingPower=0) => Symbol{id, lbp}
* prefix(id, nud) => Symbol{id, nud}

* bindingPowers: `;` < `=` < `?` < `+` < `*` < `!` < `(`
* advance(rbp) => advanceuntil a `lbp`<`rbp` is found

[good python article](https://effbot.org/zone/simple-top-down-parsing.htm)
* python
* good article

https://en.wikipedia.org/wiki/Operator-precedence_parser
https://en.wikipedia.org/wiki/Pratt_parser
* a Pratt parser is an improved recursive descent parser that associates semantics with tokens instead of grammar rules

https://github.com/percolate/pratt-parser
* python implementation



[original Pratt paper](https://tdop.github.io/)

[npm pratt-expr](https://www.npmjs.com/package/pratt-expr/v/1.0.0)
* typescript
[npm pratt-parser](https://www.npmjs.com/package/pratt-parser/v/2.0.16)
* https://github.com/arlac77/pratt-parser#readme
* 4 days ago!

http://effbot.org/zone/simple-top-down-parsing.htm
less efficient for expression syntaxes, especially for languages with lots of operators at different precedence levels


https://dev.to/jrop/pratt-parsing 2018-07-09
* article with typescript implementation
* https://github.com/jrop/pratt-calculator

https://willspeak.me/2016/09/03/top-down-operator-precedence-parsing-in-rust.html
The simplest way to create a hand-rolled parser is using recursive decent. In this parsing method each non-terminal in the grammar is converted into a function which encodes it’s parsing logic. This is great for parsing things like function definitions, variable declarations and other parts of a language which can be easily recognised from their prefix. Where it falls down a bit however is parsing expressions with infix operators. This is where Pratt operator precedence parsing comes in.

https://www.engr.mun.ca/~theo/Misc/pratt_parsing.htm (Theodore S. Norvell (C) 2016)
https://www.engr.mun.ca/~theo/Misc/exp_parsing.htm


https://tomassetti.me/parsing-in-javascript/ (July 19, 2017)
* **all the libs**
* https://github.com/GregRos/parjs
* https://github.com/j-s-n/WebBS

## matklad
https://matklad.github.io/2020/04/13/simple-but-powerful-pratt-parsing.html
* handwritten parsing: pratt | rdp
* https://github.com/matklad/minipratt

https://matklad.github.io/2020/04/15/from-pratt-to-dijkstra.html
* This is a sequel to the previous post about Pratt parsing. Here, we’ll study the relationship between top-down operator precedence (Pratt parsing) and the more famous shunting yard algorithm. Spoiler: they are the same algorithm, the difference is implementation style with recursion (Pratt) or a manual stack (Dijkstra).

## oilshell
* [Pratt Parsing Index and Updates 2020-04-18](http://www.oilshell.org/blog/2017/03/31.html) (Last updated 2020-04-18)
  * precedence climbing algorithm ~ special case of the earlier Pratt parsing algorithm
  * [Review of Pratt/TDOP Parsing Tutorials](http://www.oilshell.org/blog/2016/11/02.html)
  * https://github.com/andychu/pratt-parsing-demo
  * https://github.com/desmosinc/pratt-parser-blog-code
  * https://matklad.github.io/2020/04/13/simple-but-powerful-pratt-parsing.html

## eli
https://eli.thegreenplace.net/2010/01/02/top-down-operator-precedence-parsing (2010-01-02)
* pratt / python
https://eli.thegreenplace.net/2012/08/02/parsing-expressions-by-precedence-climbing
https://eli.thegreenplace.net/2009/03/20/a-recursive-descent-parser-with-an-infix-expression-evaluator/
[104 lines (91 sloc)  3.15 KB](https://github.com/darius/sketchbook/blob/master/parsing/precedence_climbing.py)
[47 lines (42 sloc)  1.42 KB](https://github.com/darius/sketchbook/blob/master/parsing/pratt.py)


# Bob Nystrom
http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/
* java


https://abarker.github.io/typped/pratt_parsing_intro.html
lexer: lex; lex.next()=>nextToken; lex.peek()=>nextToken (without consuming it); lext.token: current (last next)



## JS Parser combinators

* https://github.com/jneen/parsimmon
  * ugly/verbose API
* arjs
* eulalie: fail()=>ParseError; item(char)=>ParseResult
  * seq(parser, next)
  * either(parser1, parser2)
* unparse
  * parsers are objects
* lop 23k helpfulerrors
* panda-grammar
* prsc

## Lezer, a LR parser generator


## benchmark

lib o/s; KB  | phone | xps13 |  KB
-------------|-------|-------|-----
chevrotain   |   634 |  1223 | 400
*handbuilt*  |   518 |   761 |   7
myna         |   132 |   232 |  66
antlr4       |   129 |   289 | 440
peg.js       |   122 |   259 |  48
*parsimmon*  |   122 |   288 |  18
jison        |    72 |   170 |  34
nearley      |    50 |   172 |  36
