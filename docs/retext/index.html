<!doctype html>
<html lang=en>
<head>
	<title data-lang>text replacer//remplacement de texte</title>
	<meta charset=utf-8>
	<meta name=viewport content="width=device-width, initial-scale=1.0">
	<meta name=description content="text replacer">
	<link rel="stylesheet" href="../_src/main.css">
	<script type=module src="../_src/data-lang.js"></script>
</head>

<body>

<div style="display: flex; justify-content: space-between;">
	<h2><a data-lang="this.href=`/#${this.lang}`"><i><svg><use href="/icon.svg#dice"></use></svg></i></a> schem.ist</h2>
	<h2 data-lang>text replacer//remplacement de texte</h2>
	<data-lang>en fr</data-lang>
</div>
<hr>
<div data-lang>
	<span lang=en>
		String <i>replacement</i> of some, or all matches of a <i>pattern</i>.<br>
		The <i>pattern</i> can be a string or a RegExp, and the <i>replacement</i> is a string pattern
		(<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace">reference</a>)
	</span>
	<span lang=fr>
		<i>Remplacement</i> de partie(s) d'un texte où il y a correspondance à un <i>modèle</i>.<br>
		Le <i>modèle</i> utilisé peut être une RegExp et le <i>remplacement</i> est une chaîne avec les instructions pour le remplacement
		(<a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/String/replace">référence</a>).
	</span>
</div>

<h3 data-lang>pattern // modèle</h3>
<pre><code id=regexp contenteditable=true>/(c)(e)(?&lt;Lx2&gt;ll)/g</code></pre>

<h3 data-lang>replacement // remplacement</h3>
<pre><code id=action contenteditable=true>($`-$&-$')($`-$1-$2-$&lt;Lx2&gt;-$')</code></pre>

<h3>source</h3>
<pre><code id=string contenteditable=true data-lang>excellent</code></pre>

<h3 data-lang>result // résultat</h3>
<pre id=result></pre>

<script type=module>
import {$, $$} from '/_npm/@hugov/inhtml.js'
import hashData from '../_src/hash-data.js'

const regexpEl = $('#regexp'),
			actionEl = $('#action'),
			stringEl = $('#string'),
			resultEl = $('#result')

let last = '',
		wrkr

resetWorker()

function resetWorker() {
	if (wrkr) wrkr.terminate()
	wrkr = new Worker('./worker.js')
	wrkr.onerror = e => {
		resultEl.textContent = ' ! ' + e.message
		resetWorker()
	}
	wrkr.onmessage = e => {
		const {regexp, action, string, result} = e.data
		if (regexp + action + string === last) resultEl.textContent = result
	}
}

const dohash = hashData( ({lang, data}) => {
	let regexp, action, string
	resultEl.textContent = '...'
	if (data) {
		[regexp, action, string] = data.split('\0')
		regexpEl.textContent = regexp
		actionEl.textContent = action
		stringEl.textContent = string
	} else {
		regexp = regexpEl.textContent
		action = actionEl.textContent
		string = stringEl.textContent
	}
	last = regexp + action + string
	wrkr.postMessage({ regexp, action, string })
})

regexpEl.oninput = actionEl.oninput = stringEl.oninput = () => {
	console.log('oninput', regexp, action, string)
	dohash({data: [regexpEl.textContent, actionEl.textContent, stringEl.textContent].join('\0')})
}

</script>
</body>
